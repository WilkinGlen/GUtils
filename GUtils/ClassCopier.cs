namespace GUtils;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using System.Net;
using System.Reflection;
using System.Threading;

public class ClassCopier
{
    private static readonly JsonSerializerSettings SharedSettings = new()
    {
        ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
        ContractResolver = new IgnoreDelegateContractResolver(),
        TypeNameHandling = TypeNameHandling.All,
        Converters = [new IPAddressConverter()],
        ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor
    };

    /// <summary>
    /// Creates a deep copy of an object using JSON serialization.
    /// </summary>
    /// <typeparam name="T">The type of object to copy. Must be JSON-serializable.</typeparam>
    /// <param name="source">The source object to copy</param>
    /// <returns>A deep copy of the source object</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> is null.</exception>
    /// <exception cref="InvalidOperationException">Thrown when deserialization fails or results in null.</exception>
    public static T DeepCopy<T>(T source)
    {
        ArgumentNullException.ThrowIfNull(source);

        var jsonString = JsonConvert.SerializeObject(source, SharedSettings);
        var result = JsonConvert.DeserializeObject<T>(jsonString, SharedSettings);

        return result ?? throw new InvalidOperationException(
            "Deserialization resulted in null. The type may not be supported for deserialization.");
    }

    private sealed class IgnoreDelegateContractResolver : DefaultContractResolver
    {
        private readonly Dictionary<Type, List<MemberInfo>> memberCache = [];
        private readonly Dictionary<Type, HashSet<string>> readOnlyPropertiesCache = [];
        private readonly Lock cacheLock = new();

        protected override List<MemberInfo> GetSerializableMembers(Type objectType)
        {
            if (this.TryGetCachedMembers(objectType, out var cachedMembers))
            {
                return cachedMembers;
            }

            var members = base.GetSerializableMembers(objectType);
            var privateFields = GetPrivateFieldsExcludingAutoGenerated(objectType, members);
            var publicProperties = objectType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            var backingFieldsToExclude = new HashSet<FieldInfo>();
            var readOnlyPropertiesWithBackingFields = new HashSet<string>();

            IdentifyBackingFieldsForReadOnlyProperties(
                publicProperties,
                privateFields,
                objectType,
                backingFieldsToExclude,
                readOnlyPropertiesWithBackingFields);

            var allMembers = CombineMembersAndFields(members, privateFields, backingFieldsToExclude);

            this.CacheResults(objectType, allMembers, readOnlyPropertiesWithBackingFields);

            return allMembers;
        }

        protected override JsonProperty CreateProperty(
            MemberInfo member,
            MemberSerialization memberSerialization)
        {
            var property = base.CreateProperty(member, memberSerialization);

            ConfigurePropertySerialization(property);
            this.ConfigurePropertyWritability(property, member);

            return property;
        }

        private bool TryGetCachedMembers(Type objectType, out List<MemberInfo> cachedMembers)
        {
            lock (this.cacheLock)
            {
                return this.memberCache.TryGetValue(objectType, out cachedMembers!);
            }
        }

        private static List<FieldInfo> GetPrivateFieldsExcludingAutoGenerated(Type objectType, List<MemberInfo> existingMembers)
        {
            return [.. objectType
                .GetFields(BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(f => !existingMembers.Contains(f) && !f.Name.Contains("k__BackingField"))];
        }

        private static void IdentifyBackingFieldsForReadOnlyProperties(
            PropertyInfo[] publicProperties,
            List<FieldInfo> privateFields,
            Type objectType,
            HashSet<FieldInfo> backingFieldsToExclude,
            HashSet<string> readOnlyPropertiesWithBackingFields)
        {
            foreach (var property in publicProperties)
            {
                if (!IsReadOnlyProperty(property))
                {
                    continue;
                }

                var backingField = FindMatchingBackingField(property, privateFields);
                if (backingField != null)
                {
                    _ = backingFieldsToExclude.Add(backingField);
                    _ = readOnlyPropertiesWithBackingFields.Add($"{objectType.FullName}.{property.Name}");
                }
            }
        }

        private static bool IsReadOnlyProperty(PropertyInfo property)
        {
            return property.CanRead && property.GetSetMethod(true) == null;
        }

        private static FieldInfo? FindMatchingBackingField(PropertyInfo property, List<FieldInfo> privateFields)
        {
            return privateFields.FirstOrDefault(field => IsBackingFieldForProperty(field, property));
        }

        private static bool IsBackingFieldForProperty(FieldInfo field, PropertyInfo property)
        {
            var propertyName = property.Name;
            var expectedCamelCase = $"_{char.ToLower(propertyName[0])}{propertyName.AsSpan(1)}";
            var expectedSameCase = $"_{propertyName}";

            var nameMatches = field.Name == expectedCamelCase || field.Name == expectedSameCase;
            var typeMatches = field.FieldType == property.PropertyType ||
                             property.PropertyType.IsAssignableFrom(field.FieldType);

            return nameMatches && typeMatches;
        }

        private static List<MemberInfo> CombineMembersAndFields(
            List<MemberInfo> baseMembers,
            List<FieldInfo> privateFields,
            HashSet<FieldInfo> fieldsToExclude)
        {
            var fieldsToInclude = privateFields
                .Where(f => !fieldsToExclude.Contains(f))
                .Cast<MemberInfo>();

            return [.. baseMembers, .. fieldsToInclude];
        }

        private void CacheResults(
            Type objectType,
            List<MemberInfo> allMembers,
            HashSet<string> readOnlyPropertiesWithBackingFields)
        {
            lock (this.cacheLock)
            {
                this.memberCache[objectType] = allMembers;
                this.readOnlyPropertiesCache[objectType] = readOnlyPropertiesWithBackingFields;
            }
        }

        private static void ConfigurePropertySerialization(JsonProperty property)
        {
            if (typeof(Delegate).IsAssignableFrom(property.PropertyType))
            {
                property.ShouldSerialize = _ => false;
            }

            if (property.DeclaringType == typeof(IPAddress) && property.PropertyName == "ScopeId")
            {
                property.ShouldSerialize = _ => false;
            }

            property.Readable = true;
        }

        private void ConfigurePropertyWritability(JsonProperty property, MemberInfo member)
        {
            if (member is not PropertyInfo propInfo)
            {
                property.Writable = true;
                return;
            }

            var declaringType = propInfo.DeclaringType;
            if (declaringType == null)
            {
                property.Writable = propInfo.GetSetMethod(true) != null;
                return;
            }

            property.Writable = this.DeterminePropertyWritability(propInfo, declaringType);
        }

        private bool DeterminePropertyWritability(PropertyInfo propInfo, Type declaringType)
        {
            lock (this.cacheLock)
            {
                if (this.readOnlyPropertiesCache.TryGetValue(declaringType, out var readOnlyProps))
                {
                    var fullPropertyName = $"{declaringType.FullName}.{propInfo.Name}";
                    return !readOnlyProps.Contains(fullPropertyName) && propInfo.GetSetMethod(true) != null;
                }

                return propInfo.GetSetMethod(true) != null;
            }
        }
    }

    private sealed class IPAddressConverter : JsonConverter<IPAddress>
    {
        public override void WriteJson(JsonWriter writer, IPAddress? value, JsonSerializer serializer)
        {
            writer.WriteValue(value?.ToString());
        }

        public override IPAddress? ReadJson(
            JsonReader reader,
            Type objectType,
            IPAddress? existingValue,
            bool hasExistingValue,
            JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                return null;
            }

            var addressString = reader.Value?.ToString();
            return addressString == null ? null : IPAddress.Parse(addressString);
        }
    }
}
